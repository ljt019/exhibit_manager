name: Build and Release

on:
  push:
    branches:
      - main # Change to your default branch if different

jobs:
  release:
    runs-on: windows-latest

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Rust environment
      - name: Set up Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          rust-version: stable

      # Step 3: Install GitHub CLI
      - name: Install GitHub CLI
        run: |
          winget install --id GitHub.cli -e --source winget
        shell: pwsh

      # Step 4: Authenticate GitHub CLI
      - name: Authenticate GitHub CLI
        run: echo $env:GITHUB_TOKEN | gh auth login --with-token
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Step 5: Extract Application Version and Product Name
      - name: Get Application Version and Product Name
        id: app_info
        shell: pwsh
        run: |
          $appConf = "application/src-tauri/tauri.conf.json"
          if (-Not (Test-Path $appConf)) {
            Write-Error "tauri.conf.json not found at $appConf"
            exit 1
          }
          $json = Get-Content $appConf | ConvertFrom-Json
          $productName = $json.package.productName
          $version = $json.package.version
          Write-Output "product_name=$productName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Output "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      # Step 6: Extract Backend Version and Name
      - name: Get Backend Version and Name
        id: backend_info
        shell: pwsh
        run: |
          $backendToml = "backend/Cargo.toml"
          if (-Not (Test-Path $backendToml)) {
            Write-Error "Cargo.toml not found at $backendToml"
            exit 1
          }
          $tomlContent = Get-Content $backendToml -Raw
          # Extract name
          if ($tomlContent -match 'name\s*=\s*"([^"]+)"') {
            $name = $matches[1]
          } else {
            Write-Error "Package name not found in $backendToml"
            exit 1
          }
          # Extract version
          if ($tomlContent -match 'version\s*=\s*"([^"]+)"') {
            $version = $matches[1]
          } else {
            Write-Error "Version not found in $backendToml"
            exit 1
          }
          Write-Output "name=$name" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Output "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      # Step 7: Create Release for Application
      - name: Create Release for Application
        if: steps.app_info.outputs.version && steps.app_info.outputs.version != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $appVersion = "${{ steps.app_info.outputs.version }}"
          $productName = "${{ steps.app_info.outputs.product_name }}"
          $releaseTag = "$productName-v$appVersion"
          $releaseName = "$productName v$appVersion"

          # Check if release exists
          $releaseExists = gh release view $releaseTag -q exists 2>$null
          if (-Not $releaseExists) {
            Write-Host "Release $releaseTag does not exist. Creating release."

            # Build the Tauri application
            cd application
            cargo tauri build --release
            cd ..

            # Optionally, package the build artifacts
            # Example: Compress-Archive -Path application/target/release/* -DestinationPath build/app.zip

            # Create the release
            gh release create $releaseTag --title "$releaseName" --notes "Release $releaseName" --generate-notes

            Write-Host "Application release $releaseName created."
          }
          else {
            Write-Host "Application release $releaseTag already exists. Skipping."
          }

      # Step 8: Create Release for Backend
      - name: Create Release for Backend
        if: steps.backend_info.outputs.version && steps.backend_info.outputs.version != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $backendVersion = "${{ steps.backend_info.outputs.version }}"
          $backendName = "${{ steps.backend_info.outputs.name }}"
          $releaseTag = "$backendName-v$backendVersion"
          $releaseName = "$backendName v$backendVersion"

          # Check if release exists
          $releaseExists = gh release view $releaseTag -q exists 2>$null
          if (-Not $releaseExists) {
            Write-Host "Release $releaseTag does not exist. Creating release."

            # Build the backend
            cd backend
            cargo build --release
            cd ..

            # Optionally, package the build artifacts
            # Example: Compress-Archive -Path backend/target/release/* -DestinationPath build/backend.zip

            # Create the release
            gh release create $releaseTag --title "$releaseName" --notes "Release $releaseName" --generate-notes

            Write-Host "Backend release $releaseName created."
          }
          else {
            Write-Host "Backend release $releaseTag already exists. Skipping."
          }
