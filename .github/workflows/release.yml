name: Build and Release

on:
  push:
    branches:
      - main # Change to your default branch if different

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-latest

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Rust environment
      - name: Set up Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          target: x86_64-pc-windows-msvc
          cache: cargo

      # Step 3: Cache npm dependencies
      - name: Cache npm dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            !~/.npm/_logs
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-

      # Step 4: Install Node.js
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16" # Specify your Node.js version
          cache: "npm"

      # Step 5: Install project dependencies "in application directory"
      - name: Install dependencies
        run: |
          cd application
          npm install
          cd ..

      # Step 6: Extract Application Version and Product Name
      - name: Get Application Version and Product Name
        id: app_info
        shell: pwsh
        run: |
          $appConf = "application/src-tauri/tauri.conf.json"
          if (-Not (Test-Path $appConf)) {
            Write-Error "tauri.conf.json not found at $appConf"
            exit 1
          }
          $json = Get-Content $appConf | ConvertFrom-Json
          $productName = $json.package.productName
          $version = $json.package.version
          Write-Output "product_name=$productName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Output "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      # Step 7: Extract Backend Version and Name
      - name: Get Backend Version and Name
        id: backend_info
        shell: pwsh
        run: |
          $backendToml = "backend/Cargo.toml"
          if (-Not (Test-Path $backendToml)) {
            Write-Error "Cargo.toml not found at $backendToml"
            exit 1
          }
          $tomlContent = Get-Content $backendToml -Raw
          # Extract name
          if ($tomlContent -match 'name\s*=\s*"([^"]+)"') {
            $name = $matches[1]
          } else {
            Write-Error "Package name not found in $backendToml"
            exit 1
          }
          # Extract version
          if ($tomlContent -match 'version\s*=\s*"([^"]+)"') {
            $version = $matches[1]
          } else {
            Write-Error "Version not found in $backendToml"
            exit 1
          }
          Write-Output "name=$name" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Output "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      # Step 8: Check if Application Release Exists
      - name: Check if Application Release Exists
        id: check_release_app
        uses: actions/github-script@v6
        with:
          script: |
            const tag = `app-v${process.env.APP_VERSION}`;
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const exists = releases.data.some(release => release.tag_name === tag);
            return exists;
        env:
          APP_VERSION: ${{ steps.app_info.outputs.version }}

      # Step 9: Create Release for Application if Not Exists
      - name: Create Release for Application
        if: steps.check_release_app.outputs.result == 'false'
        id: create_release_app
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: app-v${{ steps.app_info.outputs.version }}
          release_name: ${{ steps.app_info.outputs.product_name }} v${{ steps.app_info.outputs.version }}
          body: "Release ${{ steps.app_info.outputs.product_name }} v${{ steps.app_info.outputs.version }}"
          draft: false
          prerelease: false

      # Step 10: Build the Tauri Application
      - name: Build Tauri Application
        if: steps.check_release_app.outputs.result == 'false'
        shell: pwsh
        run: |
          cd application
          npm run tauri:build
          cd ..

      # Step 11: Upload Release Asset for Application
      - name: Upload Release Asset for Application
        if: steps.check_release_app.outputs.result == 'false'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release_app.outputs.upload_url }}
          asset_path: ./application/src-tauri/target/release/your_application_build.exe # **Update this path**
          asset_name: your_application_build.exe # **Update this name**
          asset_content_type: application/octet-stream

      # Step 12: Check if Backend Release Exists
      - name: Check if Backend Release Exists
        id: check_release_backend
        uses: actions/github-script@v6
        with:
          script: |
            const tag = `backend-v${process.env.BACKEND_VERSION}`;
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const exists = releases.data.some(release => release.tag_name === tag);
            return exists;
        env:
          BACKEND_VERSION: ${{ steps.backend_info.outputs.version }}

      # Step 13: Create Release for Backend if Not Exists
      - name: Create Release for Backend
        if: steps.check_release_backend.outputs.result == 'false'
        id: create_release_backend
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: backend-v${{ steps.backend_info.outputs.version }}
          release_name: ${{ steps.backend_info.outputs.name }} v${{ steps.backend_info.outputs.version }}
          body: "Release ${{ steps.backend_info.outputs.name }} v${{ steps.backend_info.outputs.version }}"
          draft: false
          prerelease: false

      # Step 14: Build the Backend
      - name: Build Backend
        if: steps.check_release_backend.outputs.result == 'false'
        shell: pwsh
        run: |
          cd backend
          cargo build --release
          cd ..

      # Step 15: Upload Release Asset for Backend
      - name: Upload Release Asset for Backend
        if: steps.check_release_backend.outputs.result == 'false'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release_backend.outputs.upload_url }}
          asset_path: ./backend/target/release/your_backend_build.exe # **Update this path**
          asset_name: your_backend_build.exe # **Update this name**
          asset_content_type: application/octet-stream
