<code_files>[{"file_path":"./src-tauri/src\\auth\\auth_commands.rs","parts":[{"part_id":1,"content":"use oauth2::{\n    AuthorizationCode, CsrfToken, PkceCodeChallenge, PkceCodeVerifier, Scope, TokenResponse,\n};\nuse tauri::api::shell;\nuse tauri::Manager;\nuse url::Url;\n\nuse crate::TokenManager;\nuse chrono::Utc;\n\nfn start_server(tx: std::sync::mpsc::Sender<String>) -> Result<u16, String> {\n    let result = tauri_plugin_oauth::start(move |url| {\n        if let Err(e) = tx.send(url) {\n            println!(\"[OAuth] Error: Failed to send URL through channel: {}\", e);\n        }\n    });\n\n    match result {\n        Ok(port) => {\n            println!(\"[OAuth] Server started on port {}\", port);\n            Ok(port)\n        }\n        Err(e) => {\n            println!(\"[OAuth] Error: Failed to start server: {}\", e);\n            Err(e.to_string())\n        }\n    }\n}\n\n#[tauri::command]\npub fn sign_in(window: tauri::Window) {\n    println!(\"[OAuth] Starting sign-in process\");\n\n    // Get existing token store\n    let token_manager = window.state::<TokenManager>();\n    let client = token_manager.get_oauth_client();\n\n    // Generate PKCE challenge\n    let (pkce_code_challenge, pkce_code_verifier) = PkceCodeChallenge::new_random_sha256();\n\n    // Start the server\n    let (tx, rx) = std::sync::mpsc::channel();\n\n    let port = start_server(tx).expect(\"Failed to start server\");\n\n    // Set up redirect URL\n    let redirect_url = format!(\"http://localhost:{}\", port);\n    let client = client.set_redirect_uri(\n        oauth2::RedirectUrl::new(redirect_url.clone()).expect(\"Invalid redirect URL\"),\n    );\n\n    // Generate authorization URL\n    let (authorize_url, csrf_state) = client\n        .authorize_url(CsrfToken::new_random)\n        .add_scope(Scope::new(\n            \"https://www.googleapis.com/auth/userinfo.profile\".to_string(),\n        ))\n        .set_pkce_challenge(pkce_code_challenge)\n        .url();\n\n    shell::open(&window.shell_scope(), authorize_url.to_string(), None)\n        .expect(\"Failed to open browser\");\n\n    // Wait for redirect\n    let redirect_url = match rx.recv() {\n        Ok(url) => url,\n        Err(e) => {\n            println!(\"[OAuth] Error: Failed to receive redirect URL: {}\", e);\n            return;\n        }\n    };\n\n    // Parse redirect URL\n    let url = Url::parse(&redirect_url).expect(\"Invalid redirect URL\");\n\n    // Extract authorization code from redirect URL\n    let code_pair = match url.query_pairs().find(|pair| pair.0 == \"code\") {\n        Some(pair) => pair,\n        None => {\n            println!(\"[OAuth] Error: Authorization code not found in redirect URL\");\n            return;\n        }\n    };\n    let code = AuthorizationCode::new(code_pair.1.into_owned());\n\n    // Extract state and verify CSRF\n    let state_pair = match url.query_pairs().find(|pair| pair.0 == \"state\") {\n        Some(pair) => pair,\n        None => {\n            println!(\"[OAuth] Error: State not found in redirect URL\");\n            return;\n        }\n    };\n    let state = CsrfToken::new(state_pair.1.into_owned());\n\n    if state.secret() != csrf_state.secret() {\n        println!(\"[OAuth] Error: CSRF state mismatch\");\n        return;\n    }\n\n    // Exchange authorization code for token\n    let token_result = match client\n        .exchange_code(code)\n        .set_pkce_verifier(PkceCodeVerifier::new(\n            pkce_code_verifier.secret().to_string(),\n        ))\n        .request(oauth2::reqwest::http_client)\n    {\n        Ok(result) => result,\n        Err(e) => {\n            println!(\"[OAuth] Error: Failed to exchange code for token: {}\", e);\n            return;\n        }\n    };\n\n    // Get tokens from the token result\n    let access_token = token_result.access_token().secret().clone();\n    let refresh_token = token_result.refresh_token().map(|t| t.secret().clone());\n    let expires_in = token_result.expires_in().expect(\"No expires in set\");\n\n    // Create token data\n    let tokens = crate::token_manager::tokens::TokenData {\n        access_token: Some(access_token),\n        refresh_token: refresh_token.clone(),\n        expires_at: Some(Utc::now() + expires_in),\n    };\n\n    // Store the tokens (this also saves them to the persisted store)\n    token_manager.set_token_data(tokens);\n\n    println!(\"[OAuth] Sign in successful, notifying frontend\");\n\n    window\n        .emit(\"sign_in_complete\", None::<()>)\n        .expect(\"Failed to emit sign-in event\");\n}\n\n#[tauri::command]\npub fn check_if_signed_in(window: tauri::Window) -> bool {\n    let token_manager = window.state::<TokenManager>();\n\n    let response = token_manager.get_token_data().access_token.is_some();\n\n    response\n}\n\n#[tauri::command]\npub fn sign_out(window: tauri::Window) {\n    // Access the shared state to get token manager\n    let token_manager = window.state::<TokenManager>();\n\n    // Flush the token manager\n    token_manager.flush();\n\n    // Emit a sign out event\n    window\n        .emit(\"sign_out_complete\", None::<()>)\n        .expect(\"Failed to emit sign-out event\");\n}"}]},{"file_path":"./src-tauri/src\\auth\\data_commands.rs","parts":[{"part_id":1,"content":"use crate::token_manager::tokens::TokenManager;\nuse tauri::Manager;\n\n#[derive(serde::Serialize, serde::Deserialize)]\npub struct UserProfile {\n    pub id: String,\n    pub name: String,\n    pub given_name: String,\n    pub family_name: String,\n    pub picture: Option<String>,\n}\n\n#[tauri::command]\npub fn get_user_info(window: tauri::Window) -> Result<UserProfile, String> {\n    let token_manager = window.state::<TokenManager>();\n\n    let access_token = token_manager.get_valid_access_token()?;\n\n    // Use the access token to fetch user info.\n    let user_profile = reqwest::blocking::Client::new()\n        .get(\"https://www.googleapis.com/oauth2/v1/userinfo?alt=json\")\n        .header(\n            reqwest::header::AUTHORIZATION,\n            format!(\"Bearer {}\", access_token),\n        )\n        .send()\n        .map_err(|e| format!(\"Failed to fetch user profile: {}\", e))?\n        .json::<UserProfile>()\n        .map_err(|e| format!(\"Failed to parse user profile JSON: {}\", e))?;\n\n    Ok(user_profile)\n}"}]},{"file_path":"./src-tauri/src\\auth\\mod.rs","parts":[{"part_id":1,"content":"pub mod auth_commands;\npub mod data_commands;"}]},{"file_path":"./src-tauri/src\\main.rs","parts":[{"part_id":1,"content":"#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nmod auth;\nmod token_manager;\n\nuse auth::auth_commands::{check_if_signed_in, sign_in, sign_out};\nuse auth::data_commands::get_user_info;\n\nuse tauri::Manager;\n\nuse token_manager::tokens::TokenManager;\n\nuse dotenv::dotenv;\n\nfn main() {\n    dotenv().ok();\n\n    tauri::Builder::default()\n        .setup(|app| {\n            let token_manager = TokenManager::new(app.handle().clone());\n            token_manager.load_tokens();\n\n            app.manage(token_manager);\n\n            Ok(())\n        })\n        .plugin(tauri_plugin_store::Builder::default().build())\n        .invoke_handler(tauri::generate_handler![\n            sign_in,\n            sign_out,\n            check_if_signed_in,\n            get_user_info\n        ])\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}"}]},{"file_path":"./src-tauri/src\\token_manager\\mod.rs","parts":[{"part_id":1,"content":"pub mod tokens;"}]},{"file_path":"./src-tauri/src\\token_manager\\tokens.rs","parts":[{"part_id":1,"content":"use chrono::{DateTime, Utc};\nuse oauth2::TokenResponse;\nuse std::sync::{Arc, Mutex};\nuse tauri::AppHandle;\n\n/* Constants */\nconst CLIENT_ID: &str = \"883531815886-cr4nl5k7v4hf81bhmfjhe39j3r2ic5lm.apps.googleusercontent.com\";\nconst CLIENT_SECRET: &str = \"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\";\nconst AUTH_URL: &str = \"https://accounts.google.com/o/oauth2/auth\";\nconst TOKEN_URL: &str = \"https://accounts.google.com/o/oauth2/token\";\nconst REVOCATION_URL: &str = \"https://oauth2.googleapis.com/revoke\";\n\n#[derive(Debug, Clone)]\npub struct TokenData {\n    pub access_token: Option<String>,\n    pub refresh_token: Option<String>,\n    pub expires_at: Option<DateTime<Utc>>,\n}\n\npub struct TokenManager {\n    store: Arc<Mutex<OAuthTokenStore>>,\n    persisted_store: Arc<Mutex<PersistedStore>>,\n}\n\nimpl TokenManager {\n    pub fn new(app_handle: AppHandle) -> Self {\n        let store = OAuthTokenStore::new();\n        let persisted_store = PersistedStore::new(app_handle.clone());\n        Self {\n            store: Arc::new(Mutex::new(store)),\n            persisted_store: Arc::new(Mutex::new(persisted_store)),\n        }\n    }\n\n    pub fn refresh_access_token(&self) -> Result<(), String> {\n        let token_data = self.get_token_data();\n\n        // Check if theres a refresh token\n        let refresh_token = match token_data.refresh_token {\n            Some(token) => oauth2::RefreshToken::new(token),\n            None => return Err(\"No refresh token available\".to_string()),\n        };\n\n        // Check if the token needs refreshing\n        if let Some(expires_at) = token_data.expires_at {\n            // Add some buffer time (e.g., 5 minutes) to prevent edge cases\n            if expires_at > Utc::now() + chrono::Duration::minutes(5) {\n                return Ok(()); // Token is still valid\n            }\n        }\n\n        println!(\"[OAuth] Refreshing access token\");\n\n        // Get the OAuth client\n        let client = self.get_oauth_client();\n\n        // Perform the refresh token request\n        let token_result = match client\n            .exchange_refresh_token(&refresh_token)\n            .request(oauth2::reqwest::http_client)\n        {\n            Ok(result) => result,\n            Err(e) => {\n                println!(\"[OAuth] Error: Failed to refresh token: {}\", e);\n                return Err(\"Failed to refresh token\".to_string());\n            }\n        };\n\n        // Get tokens from the token result\n        let access_token = token_result.access_token().secret().clone();\n        let refresh_token = token_result.refresh_token().map(|t| t.secret().clone());\n        let expires_in = token_result.expires_in().expect(\"No expires in set\");\n\n        // Create new token data\n        let new_token_data = TokenData {\n            access_token: Some(access_token),\n            refresh_token: refresh_token,\n            expires_at: Some(Utc::now() + expires_in),\n        };\n\n        // Store the new tokenss\n        self.set_token_data(new_token_data);\n\n        println!(\"[OAuth] Successfully refreshed access token\");\n        Ok(())\n    }\n\n    // Helper method to check if the token needs refreshing\n    fn needs_refresh(&self) -> bool {\n        let token_data = self.get_token_data();\n\n        if token_data.access_token.is_none() {\n            return false; // No token to refresh\n        }\n\n        match token_data.expires_at {\n            Some(expires_at) => expires_at <= Utc::now() + chrono::Duration::minutes(5),\n            None => false, // No expiration time, assume token is valid\n        }\n    }\n\n    // Wrapper method to get a valid access token\n    pub fn get_valid_access_token(&self) -> Result<String, String> {\n        if self.needs_refresh() {\n            self.refresh_access_token()?;\n        }\n\n        self.get_token_data()\n            .access_token\n            .ok_or_else(|| \"No access token available\".to_string())\n    }\n\n    pub fn get_oauth_client(&self) -> oauth2::basic::BasicClient {\n        let store = self.lock_store();\n        store.oauth_client.clone()\n    }\n\n    fn lock_store(&self) -> std::sync::MutexGuard<'_, OAuthTokenStore> {\n        self.store.lock().expect(\"Failed to lock OAuthTokenStore\")\n    }\n\n    fn lock_persisted_store(&self) -> std::sync::MutexGuard<'_, PersistedStore> {\n        self.persisted_store\n            .lock()\n            .expect(\"Failed to lock PersistedStore\")\n    }\n\n    pub fn get_token_data(&self) -> TokenData {\n        let store = self.lock_store();\n        store.get_token_data()\n    }\n\n    pub fn set_token_data(&self, token_data: TokenData) {\n        let mut store = self.lock_store();\n        store.set_token_data(token_data);\n        drop(store);\n        self.save_tokens();\n    }\n\n    fn save_tokens(&self) {\n        let store = self.lock_store();\n        let token_data = store.get_token_data();\n        let mut persisted_store = self.lock_persisted_store();\n        persisted_store.save_tokens(&token_data);\n    }\n\n    pub fn load_tokens(&self) {\n        let mut persisted_store = self.lock_persisted_store();\n        let token_data = persisted_store.load_tokens();\n        let mut store = self.lock_store();\n        store.set_token_data(token_data);\n    }\n\n    pub fn flush(&self) {\n        let mut store = self.lock_store();\n        store.flush();\n\n        let mut persisted_store = self.lock_persisted_store();\n        persisted_store.flush();\n    }\n}\n\n#[derive(Clone)]\npub struct OAuthTokenStore {\n    oauth_client: oauth2::basic::BasicClient,\n    token_data: TokenData,\n}\n\nimpl OAuthTokenStore {\n    fn new() -> Self {\n        let client = oauth2::basic::BasicClient::new(\n            oauth2::ClientId::new(CLIENT_ID.to_string()),\n            Some(oauth2::ClientSecret::new(CLIENT_SECRET.to_string())),\n            oauth2::AuthUrl::new(AUTH_URL.to_string()).expect(\"Invalid authorization URL\"),\n            Some(oauth2::TokenUrl::new(TOKEN_URL.to_string()).expect(\"Invalid token URL\")),\n        )\n        .set_revocation_uri(\n            oauth2::RevocationUrl::new(REVOCATION_URL.to_string()).expect(\"Invalid revocation URL\"),\n        );\n\n        Self {\n            oauth_client: client,\n            token_data: TokenData {\n                access_token: None,\n                refresh_token: None,\n                expires_at: None,\n            },\n        }\n    }\n\n    fn get_token_data(&self) -> TokenData {\n        self.token_data.clone()\n    }\n\n    fn set_token_data(&mut self, token_data: TokenData) {\n        self.token_data = token_data;\n    }\n\n    fn flush(&mut self) {\n        self.token_data = TokenData {\n            access_token: None,\n            refresh_token: None,\n            expires_at: None,\n        };\n    }\n}\n\npub struct PersistedStore {\n    store: tauri_plugin_store::Store<tauri::Wry>,\n}\n\nimpl PersistedStore {\n    fn new(app_handle: AppHandle) -> Self {\n        let appdata_local = tauri::api::path::app_local_data_dir(&app_handle.config()).unwrap();\n        let store_path = appdata_local.join(\"tokens.json\");\n        let mut store = tauri_plugin_store::StoreBuilder::new(app_handle, store_path).build();\n        store.load().expect(\"Failed to load store\");\n        Self { store }\n    }\n\n    fn save_tokens(&mut self, token_data: &TokenData) {\n        println!(\"Saving tokens: {:?}\", token_data);\n\n        if let Some(access_token) = &token_data.access_token {\n            self.store\n                .insert(\n                    \"access_token\".to_string(),\n                    serde_json::Value::String(access_token.clone()),\n                )\n                .expect(\"Failed to insert access token\");\n        }\n\n        if let Some(refresh_token) = &token_data.refresh_token {\n            self.store\n                .insert(\n                    \"refresh_token\".to_string(),\n                    serde_json::Value::String(refresh_token.clone()),\n                )\n                .expect(\"Failed to insert refresh token\");\n        }\n\n        if let Some(expires_at) = &token_data.expires_at {\n            self.store\n                .insert(\n                    \"expires_at\".to_string(),\n                    serde_json::Value::String(expires_at.to_rfc3339()),\n                )\n                .expect(\"Failed to insert expires_at\");\n        }\n\n        self.store.save().expect(\"Failed to save token store\");\n    }\n\n    fn load_tokens(&mut self) -> TokenData {\n        self.store.load().expect(\"Failed to load token store\");\n\n        let access_token = self\n            .store\n            .get(\"access_token\")\n            .and_then(|v| v.as_str().map(|s| s.to_string()));\n\n        let refresh_token = self\n            .store\n            .get(\"refresh_token\")\n            .and_then(|v| v.as_str().map(|s| s.to_string()));\n\n        let expires_at = self.store.get(\"expires_at\").and_then(|v| {\n            v.as_str().map(|s| {\n                DateTime::parse_from_rfc3339(s)\n                    .expect(\"Failed to parse expires_at\")\n                    .with_timezone(&Utc)\n            })\n        });\n\n        println!(\n            \"Loaded tokens: {:?}\",\n            (&access_token, &refresh_token, &expires_at)\n        );\n\n        TokenData {\n            access_token,\n            refresh_token,\n            expires_at,\n        }\n    }\n\n    fn flush(&mut self) {\n        self.store.clear().expect(\"Failed to clear token store\");\n        self.store.save().expect(\"Failed to save token store\");\n    }\n}"}]},{"file_path":"./src-tauri/tauri.conf.json","parts":[{"part_id":1,"content":"{\n  \"$schema\": \"https://schema.tauri.app/config/1\",\n  \"build\": {\n    \"beforeDevCommand\": \"npm run dev\",\n    \"beforeBuildCommand\": \"npm run build\",\n    \"devPath\": \"http://localhost:1420\",\n    \"distDir\": \"../dist\"\n  },\n  \"package\": {\n    \"productName\": \"exhibit_manager\",\n    \"version\": \"0.1.0\"\n  },\n  \"tauri\": {\n    \"allowlist\": {\n      \"all\": false,\n      \"shell\": {\n        \"all\": false,\n        \"open\": true\n      },\n      \"http\": {\n        \"all\": true,\n        \"scope\": [\"http://localhost:3030/*\", \"https://picsum.photos/*\"]\n      }\n    },\n    \"windows\": [\n      {\n        \"title\": \"exhibit_manager\",\n        \"minWidth\": 1400,\n        \"minHeight\": 800,\n        \"width\": 1400,\n        \"height\": 800\n      }\n    ],\n    \"security\": {\n      \"csp\": null\n    },\n    \"bundle\": {\n      \"active\": true,\n      \"targets\": [\"nsis\"],\n      \"identifier\": \"com.exhibit-manager.app\",\n      \"icon\": [\n        \"icons/32x32.png\",\n        \"icons/128x128.png\",\n        \"icons/128x128@2x.png\",\n        \"icons/icon.icns\",\n        \"icons/icon.ico\"\n      ]\n    }\n  }\n}"}]}]</code_files> <user_prompt>is my tauri conf set up correctly to be able to coomunicate with google for the auth?</user_prompt> <important>
You will respond in this JSON format only, with part IDs as integers not strings:
{
  'parts_to_edit': [
    {
      'file_path': 'path/to/file',
      'parts': ['partId1', 'partId2', 'partId3']
    },
    {
      'file_path': 'path/to/another/file',
      'parts': ['partId1', 'partId6']
    }
  ],
  'preprocessor_prompt': 'clarification of why you made the decisions you did'
}
</important>
